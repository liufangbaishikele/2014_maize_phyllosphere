#! /usr/bin/env Rscript

library(argparse)
parser=ArgumentParser()
# Important arguments
parser$add_argument("-i", "--infile", help="File of permuted residuals to work on")
parser$add_argument("--genos", help="Numeric genotype file to select QTN from. (Assumes type generated by TASSEL)")
parser$add_argument("-o", "--outprefix", help="Output file prefix")
parser$add_argument("-n", "--num-qtl", nargs="*", type="integer", default=c(3,10), help="Space-separated list of number of QTL to simulate")
parser$add_argument("--herits", nargs="*",  type="double", default=c(0.5, 0.9), help="Space-separated list of heritabilities")
# Arguments that can often be ignored
parser$add_argument("-m", "--major-allele-coding", default=1, help="How major alleles are coded ")
parser$add_argument("-e", "--exponential-decay-rate", default=1, help="Rate of decay of exponential function for QTL simulation. Larger = faster decay = more small QTL")
parser$add_argument("-r", "--exponential-decay-range", default=5, help="Max value to draw the exponential decay rates from. Larger = more small QTL")
parser$add_argument("-s", "--seed", type="integer", default=1, help="Random seed for permutations and other random stuff")
args=parser$parse_args()
# setwd("/home/jgwall/Projects/282MaizeLeaf16s_cleaned/6_PowerSimulation/6c_flowering_time/")
# args=parser$parse_args(c("-i","6d_mlm.residuals.permuted.txt","-o","99_tmp", "--genos", "../6b_genos.numeric.txt" ))

# Load data
cat("Loading data for simulating QTL. (This could take a while.)\n")
phenos=read.delim(args$infile, skip=2, row.names=1, header=T)
genos=read.delim(args$genos, skip=1, row.names=1, header=T, colClasses=numeric())
set.seed(args$seed)

# Match phenotype and genotype taxa
cat("Matching genotype and phenotye data\n")
taxa = intersect(rownames(genos), rownames(phenos))
phenos = phenos[match(taxa, rownames(phenos)),]
genos = genos[match(taxa, rownames(genos)),]

if(!identical(rownames(phenos), rownames(genos))){  # Sanity check
    cat("\t### WARNING! Genotype and phenotype taxa labels are not matched. ###")
}

# Impute missing genotype data to the major allele
cat("Imputing missing genotype data to the major allele\n")
genos[is.na(genos)] = args$major_allele_coding

# If major is 1, swap major and minor alleles (mostly so don't affect phenotypes of everything quite as much)
if(args$major_allele_coding==1){
    cat("Detected that major allele coding is 1, so swapping major and minor alleles\n")
    genos = 1-genos
}

# Generate combinations of parameters with each phenotype.
#   Could do this by just looping over and doing all the work inside each loop, but this makes it easier to use lapply() later
#   Each subsequent step is put in a separate lapply() just to make them easier to understand and keep the tasks separated for easier debugging
cat("Simulating QTL...\n")
parameters=list()
i=1
for(n in args$num_qtl){
    for(h2 in args$herits){
        for(pheno in names(phenos)){
            parameters[[i]]=list()
            parameters[[i]]$name = paste(pheno, ".h2_",h2,".qtn_",n,sep="")
            parameters[[i]]$num_qtl=n
            parameters[[i]]$h2=h2
            parameters[[i]]$phenos=phenos[,pheno,drop=F]
            i=i+1
        }
    }
}
cat("\t",length(parameters),"parameter-phenotype combinations generated\n")


# Select QTN for each 
cat("\tSelecting QTN.\n")
parameters = lapply(parameters, function(params){
    qtn = sample(1:ncol(genos), size=params$num_qtl, replace=F)
    params$qtn = genos[,qtn, drop=F]
    return(params)
})

# Make additive effects of each QTN, drawn from an exponential distribution
cat("\tMaking additive effects QTN.\n")
parameters = lapply(parameters, function(params){
    # Generate effect sizes for each QTL
    points = seq(from=0, to=args$exponential_decay_range, length.out = params$num_qtl)  # Get points along the exponential distribution
    params$effect_size = dexp(points, rate=args$exponential_decay_rate) # Get the exponential density at each one
    params$effect_size = params$effect_size * sample(c(1,-1), size=params$num_qtl, replace=TRUE)  # Randomly change the effect direction of each QTL (positive or negative)
    
    #Get additive genetic components based on genotypes
    params$additive_values =  as.matrix(params$qtn) %*% params$effect_size
    return(params)
})

# Scale additive effects so that their variance makes up the appropriate amount of total variance for heritability
cat("\tScaling values to obtain desired heritability.\n")
parameters = lapply(parameters, function(params){
    # Determine how much we need to adjust phenotypes by to get the desired heritability
    error_var = var(params$phenos[,1])
    add_var = as.vector(var(params$additive_values))
    target_add = error_var * params$h2 / (1- params$h2) # This is basically taking the heritability equation "h2 = vA / (vA + Ve)" and solving for vA
    scaling = sqrt(target_add / add_var)  # How much need to scale variance by to get the desired result; take the square root b/c will be multiplying the raw values, not the variance
    
    # Scale phenotype values
    params$additive_values_adjusted = params$additive_values * scaling
    
    # Confirm get right heritability
    new_add_var = as.vector(var(params$additive_values_adjusted))
    params$new_h2 = new_add_var / (new_add_var + error_var)
    params$h2_checked=TRUE # Flag to indicate whether the new h2 passed the check to confirm it's correct
    if(abs(params$new_h2 - params$h2) >= 0.01){
          params$h2_checked=FALSE
    }
    
    return(params)
})

# Check that all h2 values are correct
fail_h2 = sapply(parameters, function(p){!p$h2_checked})
if(any(fail_h2)){
    cat("\t\t### WARNING!!", sum(fail_h2),"simulations failed to get the correct h2 value! ###\n")
}

# Generate new phenotypes
cat("\tGenerating new phenotypes.\n")
parameters = lapply(parameters, function(params){
    params$new_phenos = params$phenos + params$additive_values_adjusted
    names(params$new_phenos) = params$name
    return(params)
})
    
# Generate table of phenotypes to output
output=lapply(parameters, function(params){
    params$new_phenos
})
output=as.data.frame(output)

# Format new phenotypes for TASSEL and output
outphenos=paste(args$outprefix, ".phenos.txt", sep="")
cat("Writing output to",outphenos,"\n")
datatypes = paste("taxa", paste(rep("data", ncol(output)), collapse="\t"), sep="\t")
output=data.frame(Taxa=rownames(output), output) # Add header for Taxa column
write("<Phenotype>", outphenos)
write(datatypes, outphenos, append=T)
write.table(output, file=outphenos, sep='\t', quote=F, row.names=F, col.names=T, append=T)


# Extract values of all the simulations and output
simdata = lapply(parameters, function(params){
    mydata=data.frame(name=params$name, num_qtl=params$num_qtl, h2=params$h2, qtn=paste(names(params$qtn), collapse=","), effects=paste(params$effect_size, collapse=","))
    return(mydata)
})
simdata=do.call(rbind, simdata)
outsim=paste(args$outprefix, ".simulation_stats.txt", sep="")
write.table(simdata, file=outsim, sep="\t", quote=F, row.names=F, col.names=T)
